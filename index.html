<!doctype html><html lang="en">
    
<head><title>pel!gr~O's</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" type="image/x-icon" href="favicon.ico">
<script defer src="nanopicker.js"></script>
<style id="demoStyles">

@font-face {
    font-family : luckiest;
    src : url(luckiest.ttf);
}

:root {
    --back-color: #666;
    --holder-back: #111;
    --thumbH : 30px;
}

* {
    box-sizing: border-box;
    word-wrap: break-word;
}

body {
    padding: 0;
    margin: 0;
    background-color: var(--back-color);
    font-size: 22px;
    -webkit-hyphens: auto;
    hyphens: auto;
            text-align: center;
}

#holder {
    
    --nose-hsla: '395 100 94 1';
    --nose-h: 395;
    --nose-s: 100%;
    --nose-l: 94%;
    --nose-a: 1;
    
    --lightness: hsl(
        var(--nose-h),
        var(--nose-s),
        calc(70% + 0.3 * var(--nose-l))
    );
    
    --midness: hsl(
        var(--nose-h),
        calc(0.7 * var(--nose-s)),
        calc(0.8 * var(--nose-l))
    );
    
    --darkness: hsl(
        var(--nose-h),
        var(--nose-s),
        calc(0.7 * var(--nose-l))
    );
    
    --blackness: hsl(
        var(--nose-h),
        var(--nose-s),
        calc(0.20 * var(--nose-l))
    );
                
    --main-color: var(--lightness);
    --greyed-out: var(--darkness);
    
    display: inline-grid;
    grid-template-columns: 1fr;
    grid-template-rows: 1fr;
    
    position: relative;
    color: var(--main-color);
    background-color: var(--holder-back);
    margin: auto;
    margin-bottom: none;
    width: 100%;
    max-width: 700px;
    padding: 10px;
    font-size: 24px;
    text-align: justify;
    height: 100vh;
}

#discussion {
    position: relative;
    margin-top: 0px;
    overflow-x: hidden;
    overflow-y: auto;
    min-height: 40px;
}

a, a:hover, a:visited {
    text-decoration: none;
    color: var(--darkness);
}

.qa > div > a, .qa > div > a:hover, .qa > div > a:visited,
.qb > div > a, .qb > div > a:hover, .qb > div > a:visited
{
    color: var(--lightness);
}

pre {
    background-color: var(--back-color);
    margin: 0px;
    padding: 10px;
    color: var(--blackness);
    overflow: auto;
}

hr {
    border-top: 1px solid var(--blackness);
    border-bottom: none;
    border-left: none;
    border-right: none;
    margin: 7px 0px 7px 0px;
}

b {
    color: var(--darkness);
}

li {
    color: var(--midness);
}

li > b {
    color: var(--darkness);
}

input[type=range] {
    -webkit-appearance: none;
    -moz-appearance: none;
    display: inline-block;
    margin: 0;
    height: var(--thumbH);
    width: 100%;
    border-radius: calc(var(--thumbH) / 2);
    background-color: var(--darkness);
}

input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    background-color: var(--lightness);
    opacity: 1.7;
    height: var(--thumbH);
    margin-bottom: 0px;
    width: var(--thumbH);
    border: 3px solid var(--blackness);
    border-radius: calc(var(--thumbH) / 2);
}

input[type=range]:focus {
    outline: none;
}

.qr {
    padding: 10px;
}

.qa, .qb {
    color: var(--midness);
}

.qa:after, .qb:after {
    content: "";
    display: table;
    clear: both;
}

.qa > div, .qb > div {
    float: left;
    padding: 10px;
    height: auto;
}

.qa > div:nth-child(1),
.qb > div:nth-child(2) {
  width: 65%;
}

.qa > div:nth-child(2),
.qb > div:nth-child(1) {
  width: 35%;
}

.qa > div > b,
.qb > div > b {
    color: var(--lightness);
}

.mobr {
    display: none;
}

.hobr {
    display: inline-block;
}

.abhr {
    display: none;
}

.emp {
    font-family: luckiest;
}

.small {
    font-size: 0.8em;
}

/*possibly a portrait mobi-fone*/
@media screen and (max-width:500px) {

    .qa > div:nth-child(1),
    .qa > div:nth-child(2),
    .qb > div:nth-child(1),
    .qb > div:nth-child(2)
    {
        width: 100%;
    }
    
    .mobr {
        display: inline-block;
    }
    .hobr {
        display: none;
    }
    .abhr {
        display: block;
    }
    ul {
        text-align: left;
    }
    
}

.signature {
    text-align: right;
    font-family: 'luckiest';
    font-style: italic;
    height: 130px;
    -webkit-text-stroke: 1px var(--midness);
    user-select:none;
}

</style>
<style id="sceneStyles">

#sceneHolder {
    position: relative;
    width: 100%;
    height: 350px;
    padding: 0px;
    margin: 0px;
    overflow: hidden;
    box-sizing: border-box;
    user-select: none;
    resize: vertical;
    max-height: 75vh;
    min-height: 50px;
}

#sceneHolder::-webkit-resizer {
    background: var(--blackness);
    outline: 2px solid var(--midness);
}

#scene {
    width: 100%;
    height: 100%;
    transform-origin: 0% 0%;
    background-color: var(--back-color);
}

#scene > div > div {
    position: absolute;
}

#outDiv, #objDiv, #bubDiv, #hacDiv {
    position: absolute;
    width: 100%;
    height: 100%;
}

#bubDiv {
    pointer-events: none;
    display: none;
}

#bubDiv > div {
    pointer-events: none;
    border: 2px solid var(--lightness);
    border-radius: 50%;
    --xxx : none;
}

#hacDiv {
    position: absolute;
    top: 0px;
    left: 0px;
    height: 100%;
    width: 100%;
    pointer-events: none;
    border: 15px solid var(--blackness);
}

#addButt, #remButt {
    position: absolute;
    right: 0px;
    width: 0px;
    overflow: hidden;
    font-family: luckiest;
    font-size: 50px;
    text-align: center;
    color: var(--darkness);
    margin: 15px;
    transition: width ease-in 250ms;
    pointer-events: all;
    -webkit-text-stroke: 3px var(--lightness);
    
}

#addButt {
    top: 0px;
}

#remButt {
    bottom: 0px;
}

#zoomer {
    margin-top: 10px;
    --thumbH: 30px;
}

.hexhead {
    --hexrot: 0rad;
}

.hexhead::before, .hexhead::after {
    content: '';
    position: absolute;
    box-sizing: border-box;
    clip-path: polygon( 50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
}

.hexhead::before {
    height: 20px;
    width: 17.3px;
    top: calc(23% - 20px/2);
    left: calc(50% - 17.3px/2);
    background-color: var(--lightness);
    opacity: 0.8;
    transform: rotate(var(--hexrot));
}

.hexhead::after {
    height: 15px;
    width: 13px;
    top: calc(23% - 15px/2);
    left: calc(50% - 13px/2);
    background-color: var(--darkness);
    transform: rotate(var(--hexrot));
    /*display: none;*/
}

svg {
    height: inherit;
    width: inherit;
    display: block;
    isolation: isolate;
}

/*poor traits of a mobi fone*/
@media screen and (max-width:500px) {
    #zoomer {
        --thumbH: 60px;
    }
}

/*possibly a mobile landscraper*/
@media screen and (orientation: landscape) and (max-height: 500px) {
    
    #sceneHolder {
        height: 50vh;
    }
    
    #holder {
        max-width: 1000px;
    }
    
}

</style>
</head>

<body>
<div id="holder">
    
    <div id="numerator">
        <div id="sceneHolder">
            <div id="scene">
                <div id="outDiv"></div>
                <div id="objDiv"></div>
                <div id="bubDiv"></div>
            </div>
            <div id="hacDiv">
                <div id="addButt">+</div>
                <div id="remButt">-</div>
            </div>
        </div>
        
        <input id="zoomer" type="range" min=".20" max="1000" step="any" value="50">
    </div>
    
    <div id="discussion">
            
        <div intro class="qr">
            <b>pel!gr~O's</b>:
            these dangerously attractive shapes
            may, or may-not, rotate,
            but they're all actually the <i>same</i>
            shape... squares
            <br style="content:'A';display:block;
            margin:0.5em;">
            
            more precisely,
            <b class="emp">iNverse squares</b> ~
            every object in this scene is drawn
            toward every <i>other</i> object in the scene,
            by the inverse square of the distance
            between them
            <br><br>
            that sounds familiar! but this doesn't
            <i>look</i> familiar; that is to say,
            it actually <i>does</i> look familiar,
            except that it's instantly recognizable
            as something <i>other than</i>
            gravitational captivity
        </div>
        
        <hr>
        <div not-happening class="qr">
            so, what <i>is</i> going on here?
            <b class="emp">NOTHING</b>
            is going on here ~ there is <i>no</i> programmed
            behavior in this scene; the ONLY thing
            happening is the attraction of every object to
            every other object
            <ul style="list-style:circle;">
                <li>
                    <b>collisions</b>: there is no
                    <i>collision detection</i> - shapes
                    can NOT tell if they
                    have 'collided' with another shape
                </li><br>
                <li><b>obstacles</b>: there is no
                    <i>obstacle avoidance</i> - shapes
                    do not make any effort to avoid
                    other shapes, and none of the shapes
                    is considered an 'obstacle'
                </li><br>
                <li><b>deformation</b>: objects do not
                    alter their shape after they collide
                    with something, neither do they orient
                    themselves in ways to make their motions
                    more hydrodynamically efficient
                </li><br>
                <li><b>crash detection</b>: you may think
                    you have seen an object which knew that
                    it had been impacted with enough force
                    to be 'destroyed' - that is not happening
                </li><br>
                <li>
                    <b>organization</b>: if you think you're
                    seeing multiple shapes coordinating
                    their movements, you're not - there are
                    NO collective objects,
                    or multi-shape organisms,
                    or collaborative behaviors
                </li><br>
                <li><b>flocking</b>: ultimately,
                    different objects may appear to
                    have <i>assembled</i> the entire
                    scene in such a way as to make a
                    nearly permanent pathway for some
                    recurring 'circulatory'
                    motion - this is not happening
                    
                </li>
            </ul>
            
        </div>
        
        <div what-is-it class="qr">
            <i>If</i> nothing is happening, then
            what's happening?
            <br class="mobr">
            <br class="mobr">
            first, there are a few
            things you might notice which actually
            <i>are</i> happening
            
            <ul style="list-style:circle;">
                <li><b>cyclical universe</b>:
                objects are compelled through a
                <i>cylical</i> scene, and might be
                attracted to their own backs;
                <i class="small">
                while not technically an error,
                such an effect can't occur
                outside a cyclical environment
                </i>
                </li><br>
                <li><b>atomic fission</b>: though rare,
                it <i>is</i> possible for the position
                of an object to be such that its next
                calculated position will be INCREDIBLY
                far away;
                <i class="small">
                this IS a possible result of the calculation
                and occurs more often in tightly packed
                scenes
                </i>
                </li><br>
                <li><b>lagged to hack-tic</b>: depending
                on processing power, it is possible that
                one object's thread will lag and the object
                will seem to drift off;
                <i class="small">
                this is an error and should not happen
                </i>
                </li><br>
                <li><b>jump cut</b>: depending on processing
                power, it might happen that EVERY object will
                suddenly <b class="emp">POP</b>
                to a different location;
                <i class="small">
                this is a processing error and NOT a potential
                result of the calculation
                </i>
                </li><br>
                <li><b>perma-ban</b>: the code grows at
                O(n2) and can get pretty intense, it might
                happen that a particular object will simply
                freeze in place;
                <i class="small">
                this is a processing error - the equation
                MUST grow at that rate
                </i>
                </li>
            </ul>
            
            ok, fine; but WHAT is going on here?
            <i>HOW</i> is this the same equation as
            gravity, but not producing the same
            results?
        </div>
        
        <div equation class="qr">
            <div class="qr" style="
                color: var(--midness);
                background-color: var(--blackness);
                border-radius: 0px 10px;
                margin: 2px 20px;
                padding: 15px;
                font-size: 1.2em;
            "><i>
            Objects are attracted to
            <b style="color:var(--midness);
            font-size:1.05em;
            ">a ring around</b>
            the center of other objects,
            by the inverse square of the distance
            between them.
            </i></div>
        </div>
        
        <div negligible class="qr">
            that's <i>incredibly close</i> to the equation
            for gravity - it only differs by having
            the attraction towards a location radiating
            from the center-point of other masses,
            instead of <i>precisely to</i> the center
            <br><br>
            all of these objects are much smaller
            than, say, <b class="emp">THE MOON</b>;
            so, for example, if the moon were attracted
            to a
            one-inch circle <i>around</i> the
            center of the earth, there would be
            no appreciable difference between that
            and just journeying to the center
            of the earth
            <br><br>
            this equation can, therefore, also
            be used to create gravity simulations of
            large objects;
            it differs dramatically when the dimensions
            are relatively much closer to the radius of
            the ring around the other object's center
        </div>
        
        <hr>
        <div view-bubbles class="qr">
            double-click on the scene to pause,
            then you can click on an individual
            shape to view the
            <b class="emp">Danger Bubbles</b>
            as that shape sees them in the scene;
            remember, it's going to be the field
            view of <i>every</i> other object in
            the scene, so it might be a little
            confusing
            <br><br>
            double-click again to restart,
            or double-click on the
            <b style="font-size:1.2em;">+|-</b>
            to add and
            remove shapes;
            you can, ofcourse, use the slider
            to magnify and drag the corner
            to resize the scene
        </div>
        
        <br>
        <div hexadopoulus class="qb">

            <div id="peligro">
            <svg viewbox="0 0 600 500" data-nose="#holder"
             style="
                display: inline-block;
                vertical-align: top;
                height: 167px;
                width: 200px;
                overflow: visible;
                clip-path: polygon(0% 0%, 200% 0%, 200% 100%, 0% 100%);
                --body-color: var(--midness);
                --outline-color: var(--blackness);
                --hexapoid-color: var(--darkness);
                --fone-color: var(--darkness);
                --cam-color: var(--lightness);
             ">
                <use xlink:href="hexapoid.svg#ikon"/>
                <use xlink:href="ground.svg#ikon"
                    transform="
                        translate(300, 460)
                        scale(3)
                    "
                    style="--color: var(--blackness);"
                />
            </svg>
            </div>
            <div>
            <span style="
                font-family:luckiest;
                color: var(--darkness);
                
            ">
                what?! &nbsp; no, my butt is
                <i>NOT</i>&nbsp; that big
            </span>
            </div>
        </div>
   
        <br><hr><div class="qr signature">~queviva</div>
        
    </div>

</div>
</body>

<script type="text/javascript">

/////////////////////////////////////////////////////{
// pizzaFace - MCMLXXXVIII
//
// licensed from Aardvark Aaronson
//
const log = console.log;
/////////////////////////////////////////////////////}

(() => {
    
// prefs {

const prefs = {
    moveOnStart: true,
    listLoop: 1,
    zoom: window.matchMedia(
        `screen and (orientation: landscape)
                and (max-height: 500px)`
        ).matches ?
        100 : 250, // 750 = '1'
    maxZoom: 5,
    buttWidth : '25px',
    bubColor:   '#c30'
};

//}

// utils {

const rand = x => Math.random()*x;

const fadeVal = (per,A,B) => (A-((A-B)*per));

const fadeArray = (per,A,B) => A.map((a,i)=>a-((a-B[i])*per));

const placeDiv = (L,T,W,H,C,P) => {
    
    let obj  = document.createElement('div');
    let objS = obj.style;
    
    objS.left     = L +'px';
    objS.top      = T +'px';
    objS.width    = W +'px';
    objS.height   = H +'px';
    objS.clipPath = P;
    objS.backgroundColor = C;
    
    return [obj, objS];
    
};

//}

// scene vals {

const scene  = document.getElementById('scene');
const objDiv = document.getElementById('objDiv');
const outDiv = document.getElementById('outDiv');
const bubDiv = document.getElementById('bubDiv');

const peligro = document.getElementById('peligro');
const addButt = document.getElementById('addButt');
const remButt = document.getElementById('remButt');

let sceneQ;
let sceneQQ;

const MathPi2 = Math.PI/2;

//}

// all shapes {

let todasObj = [];

const TPO = [

    {nom:'terada',
     clp:'circle()',
     siz:[25,25,0],
     brd: [4,4],
     col:'--darkness', dur:60, cnt:0},

    {nom:'manada',
     clp:'circle()',
     siz:[18,18,0],
     brd: [4,4],
     col:'--darkness', dur:60, cnt:0},

    {nom:'cazada',
     clp:`polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)`,
     siz:[16,24,0],
     brd: [4,7],
     ori: true,
     col:'--darkness', dur:60, cnt:0},

    {nom:'ambante',
     clp:`polygon(
         50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%
     )`,
     siz:[12.5,12.5,0],
     brd: [4,4],
     ori: false,
     col:'--blackness', dur:5000, cnt:0},
    
    {nom:'gigax',
     clp:`polygon(
         50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%
     )`,
     siz:[40, 40, 0],
     brd: [4,4],
     ori: true,
     cls: 'hexhead',
     col:'--midness', dur:80, cnt:0},
     
    {nom:'torax',
     clp:'circle()',
     siz:[25, 25, 0],
     brd: [4,4],
     col:'--midness', dur:80, cnt:0},
     
    {nom:'colax',
     clp:`polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)`,
     siz:[25, 30, 0],
     brd: [6,6],
     ori: true,
     col:'--midness', dur:80, cnt:0}

]
.map(PO => {
    
    PO.siz[0] *= PO.nom.match(/amb|gig/) ? Math.sqrt(3)/2 : 1;
        
   !PO.col.match('--') || (PO.col = 'var(' + PO.col +')');
    
    PO.scl = PO.nom.match('x')  ? 200 : 200;
    
    return PO;
    
});

const zonaMesa = [
    
    [375,50,67.5,125,125,125,125],  //terada 25
    [2.5,375,25,125,125,125,125],   //manada 18
    [22.5,5,375,125,125,125,125],   //cazada 13.5
    [375,375,375,1400,375,375,375], //ambante
    
    [125,125,125,125,375,65,95],    //gigax  40
    [125,125,125,125,2.5,375,37],   //torax  25
    [125,125,125,125,32.5,5,375]    //colax  15
    
];

const lista = [
    
     {typ:3},{typ:3},{typ:3}
    //,{typ:3},{typ:3}
    
    ,{typ:2},{typ:1},{typ:0}
    ,{typ:2},{typ:1},{typ:0}
    ,{typ:2},{typ:1},{typ:0}
    
    ,{typ:4},{typ:5},{typ:6}
    
];

//}

// PerligrObj {
    
function PeligrObj (vals) {

    for (let v in vals) { this[v] = vals[v] }
    
    this.req;
    this.dif = 0;
    this.pos = [[0,0,0], vals.pos, vals.pos];
    this.ori = [0,0,0];
    
    this.reDO = vals.ori ?
        per => {this.rePOS(per);this.reORG(per)} :
        this.rePOS;
        
    this.reCAL = vals.ori ? this.upORG : this.upPOS;
    
    ['obj','out','bub'].forEach((v,i) => {
        
        [this[v], this[v+'S']] = placeDiv(
            vals.pos[0] - (this.siz[0] + (this.brd[0]*i)),
            vals.pos[1] - (this.siz[1] + (this.brd[1]*i)),
           (this.siz[0] + this.brd[0]*i) * 2,
           (this.siz[1] + this.brd[1]*i) * 2,
           [vals.col,'var(--lightness)','var(--xxx)'][i],
           [vals.clp,vals.clp,'none'][i]
        );
        
    });
    
    
    !vals.cls || this.obj.classList.add(vals.cls);
    
    this.hiBUB = () => this.bubS.borderColor =
        'var(--darkness)';
    this.loBUB = () => this.bubS.borderColor =
        'var(--lightness)';

};

PeligrObj.prototype.rePOS = function (per) {

    this.pos[2] = this.pos[2].map((v, i, _, m = sceneQ[i]) =>
        (((
            fadeVal(per, this.pos[0][i], this.pos[1][i])
        % m) + m) % m)
    );

    ['obj',  'out'].forEach((div, j) =>
    ['left', 'top'].forEach((val, i) =>
        this[div+'S'][val] =
        this.pos[2][i] -
        this.siz[i] -
        this.brd[i]*j + 'px'
    ));

};

PeligrObj.prototype.reORG = function (per) {
    
    this.ori[2] = fadeVal(per, this.ori[0], this.ori[1]);
    
    ['obj', 'out'].forEach(div => {
        
        this.objS.transform =
        this.outS.transform = 'rotate(' + this.ori[2] + 'rad)';
        this.objS.setProperty(
            '--hexrot', -1 * this.ori[2] + 'rad'
        );
        
    });
    
}

PeligrObj.prototype.upPOS = function () {

    this.pos[0] = this.pos[1];
    
    let tot = [0, 0, 0];

    for (let TO of todasObj.filter(to => to !== this)) {

        let del = TO.pos[2].map((v,i,_,
            d = v - this.pos[2][i]) =>
            d**2 > sceneQQ[i] ?
            v - Math.sign(d) * sceneQ[i] - this.pos[2][i] : d
        );
        
        let dis = Math.sqrt(del[0]**2 + del[1]**2);
        
        let bub = dis - zonaMesa[this.typ][TO.typ];
        
        tot = del.map((v,i) => tot[i] + (
            this.scl * bub * v / dis**3
        ));

    }

    this.pos[1] = this.pos[0].map((v,i) => tot[i] + v);
    
};

PeligrObj.prototype.upORG = function () {

    this.pos[0] = this.pos[1];
    this.ori[0] = this.ori[1];
    
    let tot = [0, 0, 0];

    for (let TO of todasObj.filter(to => to !== this)) {

        let del = TO.pos[2].map((v,i,_,
            d = v - this.pos[2][i]) =>
            d**2 > sceneQQ[i] ?
            v - Math.sign(d) * sceneQ[i] - this.pos[2][i] : d
        );
        
        let dis = Math.sqrt(del[0]**2 + del[1]**2);
        
        let bub = dis - zonaMesa[this.typ][TO.typ];
        
        tot = del.map((v,i) => tot[i] + (
            this.scl * bub * v / dis**3
        ));

    }

    this.pos[1] = this.pos[0].map((v,i) => tot[i] + v);
    this.ori[1] = MathPi2 + Math.atan2(tot[1], tot[0]);
    
};

PeligrObj.prototype.reRUN = function (start) {
    
    this.dif = (Date.now() - start);
    
    let per = this.dif / this.dur;
    
    if (per < 1) {
        
        this.reDO(per);

        this.req = window.requestAnimationFrame(
            () => this.reRUN(start)
        );

    } else {
        
        this.reCAL();
        this.reRUN(Date.now());
        
    }
    
};

//}

// app methods & objects {

const reSET = () => {
    
    let mag = window.getComputedStyle(objDiv).transform
              .match('matrix') ? 2 : 1;
    
    sceneQ  = [scene.offsetWidth, scene.offsetHeight, 0];
    sceneQ  = sceneQ.map(v => v * mag);
    sceneQQ = sceneQ.map(v => v**2 / 4);
    
    zonaMesa[3][3] = sceneQ[0] * 2;
    
};

const Obscene = new ResizeObserver(reSET);

const ObjX = {
    
    sel: '',
    
    add: () => {
        
        if (!ObjX.sel) return;
        
        let L = JSON.parse(JSON.stringify(TPO[ObjX.sel.typ]));
        
        L.typ = ObjX.sel.typ;
        
        L.pos = [rand(sceneQ[0]), rand(sceneQ[1]), 0];
        
        L.dur += rand(0.10 * L.dur) - 0.05 * L.dur;
        
        L.nom = L.nom + (TPO[L.typ].cnt++);
        
        todasObj.push(new PeligrObj(L));
        
        ['obj','out','bub'].forEach(v =>
            this[v+'Div'].appendChild(todasObj.at(-1)[v])
        );
        
        todasObj.at(-1).reCAL();
        
    },
    
    rem: () => {
        if (!ObjX.sel) return;
        ['obj','out','bub'].forEach(v =>
            this[v+'Div'].removeChild(ObjX.sel[v])
        );
        todasObj = todasObj.filter(to => to !== ObjX.sel);
        ObjX.sel = '';
        Burbujas.hide();
    },
    
    key: e => {
         e.charCode === 45 ? ObjX.rem() :
         e.charCode === 43 ? ObjX.add() : ''
    }
    
};

const Burbujas = {
    
    show : PO => {
        
        PO.bubS.left   = PO.pos[2][0] - PO.siz[0] +'px';
        PO.bubS.top    = PO.pos[2][1] - PO.siz[0] +'px';
        PO.bubS.width  = PO.siz[0]    * 2 +'px';
        PO.bubS.height = PO.siz[0]    * 2 +'px';
        PO.bubS.borderColor = prefs.bubColor;
        
        PO.obj.removeEventListener('mouseover', PO.hiBUB);
        PO.obj.removeEventListener('mouseout',  PO.loBUB);
        
        todasObj.filter(to => to !== PO).forEach(TO => {
            
            let rad = zonaMesa[PO.typ][TO.typ];
            
            TO.bubS.left   = TO.pos[2][0] - rad +'px';
            TO.bubS.top    = TO.pos[2][1] - rad +'px';
            TO.bubS.width  = 2 * rad +'px';
            TO.bubS.height = 2 * rad +'px';
            TO.bubS.borderColor = 'var(--lightness)';
            
            TO.obj.addEventListener('mouseover', TO.hiBUB);
            TO.obj.addEventListener('mouseout',  TO.loBUB);
           
        });
        
        bubDiv.style.display = 'block';
        addButt.style.width  = prefs.buttWidth;
        remButt.style.width  = prefs.buttWidth;
        
    },
    
    hide : () => {
        
        todasObj.forEach(TO => {
            TO.obj.removeEventListener('mouseover', TO.hiBUB);
            TO.obj.removeEventListener('mouseout',  TO.loBUB);
        });
        
        bubDiv.style.display = 'none';
        addButt.style.width  = '0px';
        remButt.style.width  = '0px';
        
    }
    
};

const Pause = {
    cnt: 0,
    tog: () => [
        () => {
            window.addEventListener('keypress', ObjX.key);
            todasObj.forEach(TO => {
                window.cancelAnimationFrame(TO.req);
                TO.obj.onpointerdown = () => {
                    Burbujas.show(TO);
                    ObjX.sel = TO;
                };
            });
            peligro.addEventListener('dblclick', addList);
        },
        () => {
            window.removeEventListener('keypress', ObjX.key);
            todasObj.forEach(TO => {
                TO.obj.onpointerdown = '';
                TO.reRUN((Date.now()) - TO.dif)
            });
            peligro.removeEventListener('dblclick', addList);
            Burbujas.hide();
        }
    ][(Pause.cnt = (Pause.cnt + 1) % 2)]()
};

const addList = () => {
    lista.forEach(L => ObjX.add(ObjX.sel = {typ:L.typ}));
}

//}

//////////////////////////////////////////////////////

In_Principio_Erat_Verbum = function () {

    [
      window, 'resize', reSET,
      window, 'keypress', e => {
        (e.charCode !== 32) || Pause.tog();
         e.preventDefault();
      },
      sceneHolder, 'dblclick', Pause.tog,
      sceneHolder, 'pointerdown', e => Obscene.observe(scene),
      sceneHolder, 'pointerup', e => Obscene.unobserve(scene),
      addButt, 'dblclick', e => {
          e.stopPropagation();
          ObjX.add();
          let TO = todasObj.at(-1);
      
          TO.obj.onpointerdown = () => {
              Burbujas.show(TO);
              ObjX.sel = TO;
          };
          TO.obj.dispatchEvent(new PointerEvent('pointerdown'));
      
      },
      remButt, 'dblclick', e => {
          e.stopPropagation();
          ObjX.rem();
      },
      zoomer, 'input', e => {
      
          let Z = parseFloat(zoomer.value, 10);
      
          Z = zoomer.value = Z < 775 && Z > 725 ? 750 : Z;
      
          let adj = (Z <= 750) ?
              (Z / 750) ** 0.5 :
              1 + (((Z - 750) / 250) ** 2) * (prefs.maxZoom - 1);
      
          scene.style.transform = 'scale(' + adj + ')';
          scene.style.width = 100 / adj + '%';
          scene.style.height = 100 / adj + '%';
      
          reSET();
      
      }
    ].reduce((x,v,i)=>
        ((i%3===0&&i!==0)?x.push([v]):x.at(-1).push(v),x)
    ,[[]]).forEach(e =>
        e[0].addEventListener(e[1], e[2], {passive:false})
    );
    
    zoomer.value = prefs.zoom;
    
    zoomer.dispatchEvent(new Event('input'));
    
    for (let i = prefs.listLoop; i--; addList());
    
    prefs.moveOnStart ? Pause.tog() : '';

}()})();

</script>

</html>